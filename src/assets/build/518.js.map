{"version":3,"file":"518.js?ver=6437364664889f1d2b21","mappings":"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","sources":["webpack://uncanny-automator-assets/./node_modules/@lit-labs/virtualizer/layouts/flow.js","webpack://uncanny-automator-assets/./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","webpack://uncanny-automator-assets/./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n            const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = this._metricsCache.getMarginSize(this._anchorIdx) ??\n            this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n            this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    _reflow() {\n        const { _first, _last } = this;\n        super._reflow();\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -(this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n                this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = false;\n        this.totalSize = 0;\n        if (config?.roundAverageSize === true) {\n            this._roundAverageSize = true;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    _getDefaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    constructor(hostSink, config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._hostSink = hostSink;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._getDefaultConfig()));\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        this._setItems(items);\n    }\n    _setItems(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._sendUnpinnedMessage();\n            this._pin = null;\n        }\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._sendStateChangedMessage();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _sendUnpinnedMessage() {\n        this._hostSink({\n            type: 'unpinned',\n        });\n    }\n    _sendVisibilityChangedMessage() {\n        this._hostSink({\n            type: 'visibilityChanged',\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        });\n    }\n    _sendStateChangedMessage() {\n        const childPositions = new Map();\n        if (this._first !== -1 && this._last !== -1) {\n            for (let idx = this._first; idx <= this._last; idx++) {\n                childPositions.set(idx, this._getItemPosition(idx));\n            }\n        }\n        const message = {\n            type: 'stateChanged',\n            scrollSize: {\n                [this._sizeDim]: this._scrollSize,\n                [this._secondarySizeDim]: null,\n            },\n            range: {\n                first: this._first,\n                last: this._last,\n                firstVisible: this._firstVisible,\n                lastVisible: this._lastVisible,\n            },\n            childPositions,\n        };\n        if (this._scrollError) {\n            message.scrollError = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this._scrollError = 0;\n        }\n        this._hostSink(message);\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n            else {\n                this._updateVisibleIndices({ emit: true });\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._sendVisibilityChangedMessage();\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map"],"names":["flow","config","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","offset","collapseMargins","a","b","m","sort","Math","min","max","MetricsCache","constructor","this","_childSizeCache","S","_marginSizeCache","_metricsCache","Map","update","metrics","marginsToUpdate","Set","keys","forEach","key","k","Number","set","add","get","averageChildSize","averageSize","totalChildSize","totalSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","index","getChildSize","getSize","getMarginSize","clear","super","arguments","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_getSize","_getAverageSize","_sizeDim","_estimatePosition","c","_first","_last","delta","pos","_getPosition","item","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","size","firstItem","lastItem","firstMin","candidateIdx","_firstVisible","cMax","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","extentErr","_calculateError","_reflow","_resetReflowState","_updateScrollSize","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed","SizeCache","_map","_roundAverageSize","roundAverageSize","value","prev","average","round","dim1","BaseLayout","_getDefaultConfig","hostSink","_latestCoords","left","top","_direction","_viewportSize","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_lastVisible","_items","_hostSink","Promise","resolve","then","_setItems","dir","_triggerReflow","viewportSize","dims","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","abs","reflowIfNeeded","force","options","block","_clampScrollPosition","val","unpin","_sendUnpinnedMessage","_updateLayout","_setPositionFromPin","_updateVisibleIndices","_sendStateChangedMessage","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","scrollPosition","itemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","_sendVisibilityChangedMessage","firstVisible","lastVisible","childPositions","message","scrollSize","range","first","last","scrollError","_num","emit"],"sourceRoot":""}